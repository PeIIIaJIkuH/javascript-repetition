# Продвинутая работа с функциями

## 2. Остаточные параметры и оператор расширения
- Переменная `arguments`:
    - Все аргументы находятся в псевдомассиве arguments под своими порядковыми номерами.
    - Недостаток: это всё же не массив, не можем, например, вызвать `map`.
    - Стрелочные функции не имеют `arguments`.

## 3. Замыкание
- `Лексическое окружение`:
    - В `JS` у каждой выполняемой функции, блока кода и скрипта есть связанный с ними внутренний (скрытый) объект, называемый лексическим окружением `Lexical Environment`.
    - Объект Лексического окружения состоит из двух частей:
        1. `Environmental Record` - объект, в котором как свойства хранятся все локальные переменные (а также некоторая другая информация, такая как значение `this`).
        2. Ссылка на внешнее лексическое окружение - то есть то, которое соответствует коду снаружи
        (снаружи от текущих фигурных скобок).
    - `Переменная` - это просто свойство специального внутреннего объекта: `Environmental Record`.
    - Получить или изменить переменную, означает, получить или изменить свойство этого объекта.
    - Итого:
        - Переменная это свойство специального внутреннего объекта, связанного с текущим выполняющимся блоком/функцией/скриптом.
        - Работа с переменными - это на самом деле работа со свойствами этого объекта.
- `Function Declaration`:
    - В отличие от переменных, объявленных с помощью `let`, они полностью инициализируются не тогда, когда выполнение доходит до них, а раньше, когда создаётся лексическое окружение.
- Внутреннее и внешнее лексическое окружение:
    - Теперь давайте продолжим и посмотрим, что происходит, когда функция получает доступ к внешней переменной.
    - При запуске функции для неё автоматически создаётся новое лексическое окружение, для хранения локальных переменных и параметров вызова.
        ```js
        let phrase = 'Hello'
        function say(name) {
            alert(`${phrase}, ${name}`)
        }
        say('John')
        ```
    - Итак, в процессе вызова функции у нас есть два лексических окружения: внутреннее (для вызываемой функции) и внешнее (глобальное).
    - Внутреннее лексическое окружение соответствует текущему выполнению `say`.
        - В нём находится одна переменная name, аргумент функции.
    - Внешнее лексическое окружение - это глобальное лексическое окружение.
        - В нём находится переменная phrase и сама функция.
    - У внутреннего лексического окружения есть ссылка outer на внешнее.
    - Когда код хочет получить доступ к переменной - сначала происходит поиск во внутреннем лексическом окружении, затем во внешнем, затем в следующем и так далее, до глобального.
    - Если переменная не была найдена, это будет ошибкой в `strict mode`. Без `strict mode`, Для обратной совместимости, присваивание несуществующей переменной создаёт новую глобальную переменную с таким именем.
    - Функция получает текущее значение внешних переменных, то есть, их последнее значение.
    - Старые значения переменных нигде не сохраняются. Когда функция хочет получить доступ к переменной, она берёт её текущее значение из своего или внешнего лексического окружения.
    - Один вызов - одно лексическое окружение
    - Новое лексическое окружение создаётся каждый раз, когда функция выполняется.
    - `Лексическое окружение` - это специальный внутренний объект.
    - Мы не можем получить его в нашем коде и изменить напрямую. Сам движок `JS` может оптимизировать его, уничтожать неиспользуемые переменные для освобождения памяти и выполнять другие уловки, но видимое поведение объекта должно оставаться таким, как было описано.
- Вложенные функции:
    - Это функция внутри другой функции.
    - Может быть возвращён.
        ```js
        function makeCounter() {
            let count = 0
            return function() {
                return count++
            }
        }
        let counter = makeCounter()
        alert(counter()) // 0
        alert(counter()) // 1
        alert(counter()) // 2
        ```
    - Как же это работает изнутри?
    Когда внутренняя функция начинает выполняться, начинается поиск переменной count++ изнутри-наружу.
    - Теперь рассмотрим два вопроса:
        1. Можем ли мы сбросить счётчик count из кода, который не принадлежит `makeCounter`?
        2. Если мы вызываем `makeCounter` несколько раз - нам возвращается много функций `counter`.
          Они независимы или разделяют одну и ту же переменную `count`?
    - Ответы:
        1. Такой возможности нет: `count` - локальная переменная, мы не можем получить к ней доступ извне.
        2. Для каждого вызова `makeCounter()` создаётся новое лексическое окружение функции, со своим собственным `count`.
- Окружение в деталях:
    1. Когда скрипт только начинает выполняться, есть только глобальное лексическое окружение.
        Все функции при рождении получают скрытое свойство `[[Environment]]`, которое ссылается на лексическое окружение места, где они были созданы.
        В данном случае, `makeCounter` создан в глобальном лексическом окружении, так что `[[Environment]]` содержит ссылку на него.
        Другими словами, функция навсегда запоминает ссылку на лексическое окружение, где она была создана.
        И `[[Environment]]` - скрытое свойство функции, которое содержит эту ссылку.
    2. Код продолжает выполняться, объявляется новая глобальная переменная `counter`, которой присваивается результат вызова `makeCounter`.
        В момент вызова `makeCounter()` создаётся лексическое окружение, для хранения его переменных и аргументов.
        Как и все лексические окружения, оно содержит две вещи:
            1. `Environmental Record` с локальными переменными. В нашем случае `count` - единственная локальная переменная.
            2. Ссылка на внешнее окружение, которая устанавливается в значение `[[Environment]]` функции.
            В данном случае, `[[Environment]]` функции `makeCounter` ссылается на глобальное лексическое окружение.
        Итак, теперь у нас есть два лексических окружения: первое - глобальное, второе - для текущего вызова `makeCounter`, с внешней ссылкой на глобальной объект.
    3. В процессе выполнения `makeCounter()` создаётся небольшая вложенная функция.
        Не имеет значения какой способ объявления функции используется: `Function Declaration` или `Function Expression`.
        Все функции получают свойство `[[Environment]]`, которое ссылается на лексическое окружение, в котором они были созданы. То же самое происходит и с нашей новой маленькой функцией.
        Для нашей новой вложенной функции значением `[[Environment]]` будет текущее лексическое окружение `makeCounter()`.
        Обратите внимание, что на этом шаге внутренняя функция была создана, но ещё не вызвана.
    4. Выполнение продолжается, вызов `makeCounter()` завершается, и результат присваивается глобальной переменной `counter`.
        В этой функции есть только одна строчка: `return count++`, которая будет выполнена, когда мы вызовем функцию.
    5. При вызове `counter()` для этого вызова создаётся новое лексическое окружение.
        Оно пустое, так как в самом counter локальных переменных нет.
        Но `[[Environment]]` counter используется как ссылка на внешнее лексическое окружение `outer`, которое даёт доступ к переменным предшествующего вызова `makeCounter`, где `counter` был создан.
        Теперь когда вызов ищет переменную `count`, он сначала ищет в собственном лексическом окружении (пустое), а затем в лексическом окружении предшествующего вызова `makeCounter()`, где и находит её.
        Обратите внимание, как здесь работает управление памятью.
        Хотя `makeCounter()` закончил выполнение некоторое время назад, его лексическое окружение остаётся в памяти, потому что есть вложенная функция с `[[Environment]]`, который ссылается на него.
        В большинстве случаев, объект лексического окружения существует до того момента, пока есть функция, которая может его использовать. И только тогда, когда таких не остаётся, окружение уничтожается.
        То есть если мы сделаем `counter = null`, то лексическое окружение уничтожается.
    6. Вызов `counter()` не только возвращает значение `count`, но также увеличивает его.
        Обратите внимание, что модификация происходит на месте. Значение `count` изменяется конкретно в том окружении, где оно было найдено.
    7. Следующие вызовы `counter()` сделают то же самое.
        Теперь ответ на второй вопрос из начала главы должен быть очевиден.
        Функция `work()` в коде получает name из того места, где была создана, через ссылку на внешнее лексическое окружение.
        Так что результатом будет `'Pete'`.
        Но если бы в `makeWorker()` не было `let name`, тогда бы поиск продолжился дальше и была бы взята глобальная переменная, как мы видим из приведённой выше цепочки. В таком случае, результатом было бы `'John'`.
    - Замыкания:
        - В программировании есть общий термин: замыкание - которое должен знать каждый разработчик.
        - `Замыкание` - это функция, которая запоминает свои внешние переменные и может получить к ним доступ.
        - В некоторых языках это невозможно, или функция должна быть написана специальным образом, чтобы получилось замыкание.
        - Но, как было описано выше, в `JS`, все функции изначально являются замыканиями (есть только одно исключение, `new Function())`.
        - То есть, они автоматически запоминают, где были созданы, с помощью скрытого свойства `[[Environment]]` и все они могут получить доступ к внешним переменным.
- Блоки кода и циклы, `IIFE`:
    - Лексическое окружение существует для любых блоков кода `{...}`.
    - Для `if`, `for`, `while` и блоков кода `{...}` создаются новые лексические окружения.
    - В браузере все скрипты, кроме `type='module'`, разделяют одну общую глобальную область.
- `IIFE`
    - В прошлом в `JS` не было лексического окружения на уровне блока кода.
    - Так что программистам пришлось что-то придумать. И то, что они сделали, называется `immediately-invoked function expressions`, что означает функцию, запускаемую сразу после объявления.
    - Это не то, что мы должны использовать сегодня, но, так как вы может встретить это в старых скриптах, полезно понимать принцип работы.
        ```js
        (function () {
            let message = 'Hello'
            alert(message)
        })
        ```
    - Здесь создаётся и немедленно вызывается `Function Expression`.
    - Так что код выполняется сразу же и у него есть свои локальные переменные.
    - `Function Expression` обёрнуто в скобки (), потому что, когда `JS` встречает `'function'` в основном потоке кода, он воспринимает это как начало `Function Declaration`.
    - Но у `Function Declaration` должно быть имя, так что такой код вызовет ошибку.
    - Даже если мы добавим имя, это не сработает, потому что `JS` не позволяет вызывать `Function Declaration` немедленно.
    - Так что, скобки вокруг функции - это трюк, который позволяет показать `JS`, что функция была создана в контексте другого выражения, и, таким образом, это функциональное выражение: ей не нужно имя и её можно вызвать немедленно.
    - Кроме скобок, существует и другие пути показать `JS`, что мы имеем в виду `Function Expression`:
        ```js
        (function() {
            // ...
        })()
        (function() {
            // ...
        }())
        !function() {
            // ...
        }()
        +function() {
            // ...
        }()
        ```
- Сборка мусора:
    ```js
    function f() {
        let value1 = 123
        let value2 = 456
    }
    f()
    ```
    - Здесь два значения, которые технически являются свойствами лексического окружения.
    - Но после того, как `f()` завершится, это лексическое окружение станет недоступно, поэтому оно удалится из памяти.
    - ...Но, если вложенная функция, которая всё ещё доступна после выполнения `f`, то у неё свойство `[[Environment]]`, которое ссылается на внешнее лексическое окружение, тем самым оставляя его достижимым, 'живым'.
    - Обратите внимание, если `f()` вызывается несколько раз и возвращаемые функции сохраняются, тогда все соответствующие объекты лексического окружения продолжат держаться в памяти.
    - Объект лексического окружения умирает, когда становится недоступным (как и любой объект).
    - Другими словами, он существует только до того момента, пока есть хотя бы одна вложенная функция, которая ссылается на него.
- Оптимизация на практике:
    - Но на практике движки `JS` пытаются это оптимизировать.
    - Они анализируют использование переменных и, если легко по коду понять, что внешняя переменная не используется - она удаляется.
    - Одним из важных побочных эффектов в `V8` (`Chrome`, `Opera`) является то, что такая переменная становится недоступной при отладке.

## 4. Устаревшее ключевое слово `var`
- `let` и `const` ведут себя одинаково по отношению к лексическому окружению, области видимости.
- Но `var` - это совершенно другой зверь.
- Для `var` не существует блочной области видимости:
    - Область видимости переменных `var` ограничивается либо функцией, либо, если переменная глобальная, то скриптом.
    - Такие переменные доступны за пределом блока.
- `var` обрабатываются в начале запуска функции:
    - Объявления переменных `var` обрабатываются в начале выполнения функции (или запуска скрипта).
    - Другими словами, переменные `var` считаются объявленными с самого начала исполнения функции вне зависимости от того, в каком месте функции реально находятся их объявления (при условии, что они не находятся во вложенной функции).
    - Это поведение называется `hoisting` (всплытие, поднятие), потому что все объявления переменных `var` 'всплывают' в самый верх функции.
    - Объявления переменных всплывают, но присваивания значения - нет.

## 5. Глобальный объект
- В браузере он называется `window`, в `Node.js` - `global`, в другой среде исполнения может называться иначе.
- Недавно `globalThis` был добавлен в язык как стандартизованное имя для глобального объекта, которое должно поддерживаться в любом окружении.
- В некоторых браузерах, например `Edge` не на `Chromium`, `globalThis` ещё не поддерживается, но легко реализуется с помощью полифила.
- Ко всем свойствам глобального объекта можно обращаться напрямую.
- В браузере глобальные функции и переменные, объявленные с помощью `var`, становятся свойствами глобального объекта.
- Не полагайтесь на это, в современных проектах, использующих `JS-модули`, такого не происходит.
- Если свойство настолько важное, что вы хотите сделать его доступным для всей программы, запишите его в глобальный объект напрямую.
    ```js
    window.x = // ...
    ```
- Но не рекомендуется использовать такие переменные.

## 6. Объект функции, NFE
- В `JS` функция - это значение.
- Каждое значение в `JS` имеет свой тип.
- В `JS` функции - это объекты.
- Можно представить функцию как объект, который может делать какое-то действие.
- Свойство `name`:
    - Объект функции содержит несколько полезных свойств.
        ```js
        function sayHi() {
            alert('Hi')
        }
        alert(sayHi.name) // sayHi
        ```
    - Логика назначения name весьма умная. Она присваивает корректное имя даже в случае, когда функция создаётся без имени и тут же присваивается.
        ```js
        let sayHi = function() {
            alert('Hi')
        }
        alert(sayHi.name) // sayHi
        ```
    - Это работает даже в случае присваивания значения по умолчанию.
    - В спецификации это называется контекстное имя: если функция не имеет `name`, то `JS` пытается определить его из контекста.
- Свойство `length`:
    - Содержит количество параметров функции в её объявлении.
        ```js
        function f1(a) {}
        function f2(a, b) {}
        function many(a, b, ...more) {}
        alert(f1.length) // 1
        alert(f2.length) // 2
        alert(f3.length) // 2
        ```
    - Троеточие как бы не считается.
- Пользовательские свойства:
    - Можем добавить свои собственные свойства.
        ```js
        function sayHi() {
            alert('Hi')
            sayHi.counter++
        }
        sayHi.counter = 0
        sayHi()
        sayHi()
        alert(sayHi.counter) // 2
        ```
    - Свойство не есть переменная:
        - Не объявляет локальную переменную `counter` внутри неё.
        - Другими словами, свойство `counter` и переменная `let counter` - это две независимые вещи.
    - Иногда свойства функции могут использоваться вместо замыканий. Например, мы можем переписать функцию-счётчик из главы - Замыкание, используя её свойство:
        ```js
        function makeCounter() {
            function counter() {
                return counter.count++
            }
            counter.count = 0
            return counter
        }
        let counter = makeCounter()
        alert(counter()) // 0
        alert(counter()) // 1
        ```
    - Основное отличие - свойство можно получить и изменить извне, а локальную переменную - нет.
- `Named Function Expression`:
    - `NFE` - это термин для `Function Expression`, у которого есть имя.
    - Например, давайте объявим `Function Expression`.
        ```js
        let sayHi = function(who) {
            alert(`Hello, ${who}`)
        }
        ```
    - И присвоим ему имя:
        ```js
        let sayHi = function func(who) {
            alert(`Hello, ${who}`)
        }
        ```
    - Функция всё ещё доступна как `sayHi()`.
    - Есть две важные особенности имени `func`, ради которого оно даётся:
        1. Оно позволяет функции ссылаться на себя же. // рекурсия
        2. Оно не доступно за пределами функции.
    - Вообще мы можем использовать `sayHi` для этого, но оно может быть изменено, и это приведёт к ошибке.
    - Это не работает с `Function Declaration`:
        - Трюк с внутренним именем работает только для `Function Expression` и не работает для `Function Declaration`.
        - Для `Function Declaration` синтаксис не предусматривает возможность объявить дополнительное внутреннее имя.

## 7. Синтаксис `new Function`
- Синтаксис:
    - Функция создаётся с заданными аргументами `arg1...argN` и телом `functionBody`.
        ```js
        let func = new Function([arg1, arg2, ...argN], functionBody)
        ```
    - Проще понять на конкретном примере.
        ```js
        let sum = new Function('a', 'b', 'return a + b')
        alert(sum(1, 2)) // 3
        ```
    - А вот функция без аргументов, в этом случае достаточно указать только тело.
        ```js
        let sayHi = new Function('alert("Hello")')
        sayHi() // Hello
        ```
    - Главное отличие от других способов объявления функции заключается в том, что фунция создаётся полностью на лету из строки, переданной во время выполнения.
    - Все предыдущие объявления требовали от нас писать объявление функции в скрипте.
    - Но `new Function` позволяет превратить любую строку в функцию. Например, можно получить новую функцию с сервера и затем выполнить её.
        ```js
        let str = ... код, полученный с сервера динамически
        let func = new Function(str)
        func()
        ```
- Замыкание:
    - Обычно функция запоминает, где родилась, в специальном свойстве `[[Environment]]`.
    - Это ссылка на лексическое окружение (`Lexical Environment`), в котором она была создана.
    - Но когда функция создаётся с использованием `new Function`, в её `[[Environment]]` записывается ссылка не на внешнее лексическое окружение, а на глобальное.
    - Поэтому такая функция имеет доступ только к глобальным переменным.
    - Эта особенность выглядит странно, но оказыватся очень полезной на практике.
    - Если бы `new Function` имела доступ к внешним переменным, при этом были бы проблемы с минификаторами.

## 8. Планирование - setTimeout и setInterval
- `setTimeout`:
    ```js
    let timerId = setTimeout(func|code, [delay], [arg1], [arg2], ...)
    ```
    -`func|code`:
        - Функция или строка для выполнения. Обычно это функция.
        - По историческим причинам можно передать и строку, но не рекомендуется.
    - `arg1, arg2, ...`:
        - Аргументы, передаваемые в функцию.
- `setInterval`:
    - Имеет такой же синтаксис как `setTimeout`.
- `setTimeout` с нулевой задержкой:
    - `setTimeout(func, 0)` или просто `setTimeout(func)`.
    - Это планирует вызов `func` настолько быстро, насколько это возможно.
    - Но планировщик будет вызывать функцию только после завершения выполнения текущего кода.

## 9. Декораторы и переадресация вызова, `call`, `apply`
- Прозрачное кеширование:
    - Представим, есть ресурсоёмкая но стабильная функция, т.е. возвращающие один и тот же результат для одного и того же `x`.
    - Если она вызыватся часто, то мы хотим её закешировать.
    - Вместо того, чтобы усложнять `slow(x)` дополнительной функциональностью, мы заключим её в функци-обёртку - `wrapper`, которая добавит кеширование.
        ```js
        function slow(x) {
            alert(`Called with ${x}`)
            return x
        }
        function cachingDecorator(func) {
            let cache = new Map()
            return function(x) {
                if (cache.has(x)) {
                    return cache.get(x)
                }
                let result = func(x)
                cache.set(x, result)
                return result
            }
        }
        slow = cachingDecorator(slow)
        alert(slow(1)) // slow(1) кешируем
        alert(slow(1)) // возвращаем из кеша
        ```
    - Подводя итог, можно выделить несколько преимуществ использования отдельной `cachingDecorator`:
        - Функцию `cachingDecorator` можно использовать повторно.
        - Логика кеширования является отдельной, она не увеличивает сложность самой `slow`.
        - При необходимости мы можем объединить несколько декораторов.
- Применение `func.call` для передачи контекста:
    - Упомянутый выше кеширующий декоратор не подходит для работы с методами объектов.
    - Возникает ошибка: Функция пытается получить доступ к `this.someMethod` и завершается с ошибкой.
    - Причина в том, что декоратор вызывает оригинальную функцию как `func(x)`, и она в данном случае получает `this = undefined`.
    - Давайте это исправим.
        ```js
        func.call(context, arg1, arg2, ...)
        ```
    - Запускает функцию `func`, используя первый аргумент как её контекст `this`, а последующие - как её аргументы.
    - В нашем случае с объектом, мы можем использовать `call` в обёртке для передачи контекста.
        ```js
        let worker = {
            someMethod() {
                return 1
            }
            slow(x) {
                alert('Called with ' + x)
                return x * this.someMethod()
            }
        }
        function cachingDecorator(func) {
            let cache = new Map()
            return function(x) {
                if (cache.has(x)) {
                    return cache.get(x)
                }
                let result = func.call(this, x) // теперь this передаётся правильно
                cache.set(x, result)
                return result
            }
        }
        worker.slow = cachingDecorator(worker.slow)
        worker.slow() // контекст worker-а передаётся в slow, т.е., this внутри slow будет равен worker-у
        ```
- Переходим к нескольким аргументам с `func.apply`:
    - Теперь сделаем `cachingDecorator` ещё более универсальным.
    - До сих пор он работал только с функциями с одним аргументом.
        ```js
        let worker = {
            slow(min, max) {
                return min + max // здесь может быть тяжёлая задача
            }
        }
        // будет кешировать вызовы с одинаковыми аргументами
        worker.slow = cachingDecorator(worker.slow)
        ```
    - Из-за того, что нам нужно закешировать и `min`, и `max` как ключи, можно выбрать следующее решение:
        - Соединить их как `min,max` как ключ к `Map`.
    - Также понадобится заменить `func.call(this, x)` на `func.call(this, ...arguments)`, чтобы передавать все аргументы обёрнутой функции, а не только первый.
        ```js
        let worker = {
            slow(min, max) {
                alert(`Called with ${min},${max}`)
                return min + max
            }
        }
        function cachingDecorator(func, hash) {
        let cache = new Map()
            return function() {
                let key = hash(arguments) // (*)
                if (cache.has(key)) {
                return cache.get(key)
                }

                let result = func.call(this, ...arguments) // (**)

                cache.set(key, result)
                return result
            }
        }
        function hash(args) {
            return args[0] + ',' + args[1]
        }
        worker.slow = cachingDecorator(worker.slow, hash)
        alert( worker.slow(3, 5) ) // работает
        alert( "Again " + worker.slow(3, 5) ) // аналогично (из кеша)
        ```
    - Теперь он работает с любым количеством аргументов.
    - Вместо `func.call(this, ...arguments)` мы могли бы написать `func.apply(this, arguments)`
    - Синтаксис:
        ```js
        func.apply(context, args)
        ```
    - Принимает в качестве списка аргументов псевдомассив `args`.
    - Единственная разница между `call` и `apply` - `call` ожидает список аргументов, в то время, `apply` принимает псевдомассив.
    - Эти два вызова почти эквивалентны:
        ```js
        func.call(context, ...args)
        func.apply(context, args)
        ```
    - Есть только одна небольшая разница:
        - Оператор расширения ... позволяет передавать перебираемый объект `args` в виде списка в `call`.
        - А apply принимает только псевдомассив `args`.
    - А если у нас объект - реальный массив, то технически можно использовать любой метод, но `apply`, вероятно, будет быстрее, так как большинство движков JS внутренне оптимизируют его лучше.
    - Перенаправление всех аргументов вместе с контекстом другой функции называется `перенаправлением вызова` (`call forwarding`).
- Заимствование метода:
    - Давайте сделаем ещё одно небольшое улучшение функции хэширования.
        ```js
        function hash(args) {
            return args[0] + ',' + args[1]
        }
        ```
    - Было бы лучше, если бы она могла склеить любое количество `args`.
    - Можно было бы использовать `args.join()`, но это не сработает.
    - Так как объект `arguments` будет перебираемым псевдомассивом, но не реальным массивом.
    - Тем не менее, есть простой способ использовать соединение массива:
        ```js
        function hash() {
            alert([].join.call(arguments)) // 1,2
        }
        hash(1, 2)
        ```
    - Этот трюк называется заимствование метода.
    - Мы берём (заимствуем) метод join из обычного массива `[].join`.
    - И используем `[].join.call`, чтобы выполнить его в контексте `argumments`.
    - Почему это работает?
    - Это связано с тем, что внутренний алгоритм метода `arr.join(glue)` очень прост.
        1. Пускай первым аргументом будет `glue` или `"`, `'` при отсутствии.
        2. Пускай `result` будет пустой строкой `''`.
        3. Добавить `this[0]` к `result`.
        4. Добавить `glue` и `this[1]`.
        5. Выполнять до тех пор, пока `this.length` элементов не будет склеено.
        6. Вернуть `result`.

## 10. Привязка контекста к функции
- При передаче методов объекта в качестве колбэков, например для `setTimeout`, возникает известная проблема - потеря `this`.
- Потеря `this`:
    - Решение 1: сделать функцию-обёртку:
        ```js
        let user = {
            firstName: 'Вася',
            sayHi() {
                alert(`Привет ${this.firstName}`)
            }
        }
        setTimeout(function() {
            user.sayHi()
        }, 1000)
        ```
        - Выглядит хорошо, но теперь в нашем коде появилась небольшая уязвимость.
        - Что произойдёт, если до момента срабатывания `setTimeout` в переменную `user` будет записано другое значение? - - - Тогда вызов неожиданно будет совсем не тот!
    - Решение 2: привязать контекст с помощью `bind`:
        ```js
        let boundFunc = func.bind(context)
        ```
        - Результатом вызова `func.bind(context)` является особый экзотический объект, который вызывается как функция и прозрачно передаёт вызов в `func`,  при этом устанавливая `this=context`.
        - Другими словами, вызов `boundFunc` подобен вызову `func` с фиксированным `this`.
        - Например, здесь `funcUser` передаёт вызов в `func`, фиксируя `this=user`.
            ```js
            let user = {
                firstName: 'Вася'
            }
            function func() {
                alert(this.firstName)
            }
            let funcUser = func.bind(user)
            funcUser() // Вася
            ```
        - Теперь давайте попробуем с методом объекта:
            ```js
            let user = {
                firstName: 'Вася',
                sayHi() {
                    alert(`Привет, ${this.firstName}`)
                }
            }
            let sayHi = user.sayHi.bind(user) // (*)
            sayHi() // Привет, Вася
            setTimeout(sayHi, 1000) // Привет, Вася
            ```
        - В строке `(*)` мы берём метод `user.sayHi` и привязываем его к user.
        - Теперь `sayHi` - это связанная функция, которая может быть вызвана отдельно или передана в `setTimeout` (контекст всегда будет правильным).
        - Удобный методв: `bindAll`:
            - Если у объекта много методов и мы планируем их автивно передавать, то можно привязать контекст для них всех в цикле.
                ```js
                for (let key in user) {
                    if (typeof user[key] == 'function') {
                        user[key] = user[key].bind(user)
                    }
                }
                ```
- Частичное применение:
    - Мы можем привязать не только `this`, но и аргументы.
        ```js
        let bound = func.bind(context, [arg1], [arg2], ...)
        ```
    - Например:
        ```s
        function mul(a, b) {
            return a * b
        }
        let double = mul.bind(null, 2)
        alert(double(3)) // 6
        alert(double(4)) // 8
        alert(double(5)) // 10
        ```
- Частичное применение без контекста:
    - Что если мы хотим зафиксировать некоторые аргументы, но не контекст `this`?
    - Встроенный `bind` не позволяет этого.
    - Решение:
        ```js
        function partial(func, ...argsBound) {
            return function(...args) {
                return func.call(this, ...argsBound, ...args)
            }
        }
        let user = {
            firstName: 'John',
            say(time, phrase) {
                alert(`[${time}] ${this.firstName}: ${phrase}!`)
            }
        }
        user.sayNow = partial(user.say, new Date().getHours() + ':' + new Date().getMinutes())
        user.sayNow('Hello')
        // [10:00] John: Hello!
        ```

## 11. Повторяем стрелочные функции
- Не просто сокращение, есть ряд других полезных особенностей.
- У стрелочных функций нет `this`:
    - Если происходит обращение к `this`, его значение берётся снаружи.
- Стрелочные функции нельзя использовать с `new`.
    - Отсутствие `this` естественным образом ведёт к другому ограничению.
    - Стрелочные функции не могут быть использованы как конструкторы.
- Стрелочные функции `VS bind`:
    - Тонкая разница между стрелочной функцией и обычной функцией, вызванной с `.bind(this)`:
        - `.bind(this)` создаёт 'связанную версию' функции.
        - Стрелка `=>` ничего не привязывает. У функции просто нет `this`.
- Стрелочные функции не имеют `arguments`:
    - Это отлично подходит для декораторов, когда нам нужно пробросить вызов с текущими `this` и `arguments`.

