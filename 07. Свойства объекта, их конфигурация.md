# Свойства объекта, их конфигурация

## 1. Флаги и дескрипторы свойств
- Флаги свойств:
    - `writable`:
        - Если `true`, свойство можно изменить, иначе оно только для чтения.
    - `enumerable`:
        - Если `true`, свойство перечисляется в циклах, иначе его игнорируют.
    - `configurable`:
        - Если `true`, свойство можно удалить, а эти атрибуты можно изменять, иначе этого делать нельзя.
    - Когда мы создаём объекты обычным способом, все имеют значение `true`.
    - Метод `Object.getOwnPropertyDescriptor` позволяет получить полную информацию о свойстве.
        ```js
        let descriptor = Object.getOwnPropertyDescriptor(obj, propertyName)
        ```
    - Чтобы изменить флаги, мы можем использовать метод `Object.defineProperty`.
        ```js
        Object.defineProperty(obj, propertyName, descriptor)
        ```
    - Если свойство существует, `defineProperty` обновит его флаги.
    - Если нет, метод создаёт новое свойство с указанным значением и флагами.
    - Если какой-нибудь флаг не указан явно, ему присваивается `false`.
        ```js
        let user = {}
        Object.defineProperty(user, 'name', {
            value: 'John'
        })
        let descriptor = Object.getOwnPropertyDescriptor(user, 'name')
        alert(JSON.stringify(descriptor, null, 2))
        // {
        //   "value": "John",
        //   "writable": false,
        //   "enumerable": false,
        //   "configurable": false
        // }
        ```
- Если свойство только для чтения, то при попытке изменить ошибка появляется только в строгом режиме.
- Определение свойства как неконфигурируемого - это дорога в один конец.
- Мы не сможем отменить это действие, потому что `defineProperty` не работает с неконфигурируемыми свойствами.
- Если свойство неконфигурируемо, то при попытке записи в такое свойство ошибка появляется только в строгом режиме.
- Метод `Object.defineProperties`:
    - Позволяет определять множество свойства сразу.
        ```js
        Object.defineProperties(obj, {
            prop1: descriptor1,
            prop2: descriptor2
            /// ...
        })
        ```
- `Object.getOwnPropertyDescriptors`:
    - Получает все дескрипторы свойств.
    - Вместе с `Object.defineProperties` этот метод можно использовать для клонирования объекта вместе с его флагами.
        ```js
        let clone = Object.defineProperties({}, Object.getOwnPropertyDescriptors(obj))
        ```
    - Обычно при клонировании объекта мы используем присваивание, чтобы скопировать его свойства.
    - Но это не копирует флаги. Так что если нам нужен клон получше, предпочтительнее использовать `Object.defineProperties`.
    - Другое отличие в том, что `for..in` игнорирует символьные свойства, а `Object.getOwnPropertyDescriptors` возвращает дескрипторы всех свойства, включая свойства-символы.
- Глобальное запечатывание объекта:
    - `Object.preventExtensions(obj)`:
        - Запрещает добавлять новые свойства в объект.
    - `Object.seal(obj)`:
        - Запрещает добавлять/удалять свойства. Устанавливает `configurable: false` для всех свойств.
    - `Object.freeze(obj)`:
        - Запрещает добавлять/удалять/изменять свойства.
        - Устанавливает `configurable: false, writable: false` для всех свойств.
- Методы их проверки:
    - `Object.isExtensible(obj)`:
        - Возвращает `false`, если добавление свойств запрещено, иначе `true`.
    - `Object.isSealed(obj)`:
        - Возвращает `false`, если добавление/удаление свойств запрещено и для всех свойств установлено `configurable: false`.
    - `Object.isFrozen(obj)`:
        - Возвращает `true`, если добавление/удаление/изменение свойств запрещено, и для всех свойств установлено `configurable: false, writable: false`.

## 2. Свойства - геттеры и сеттеры
- Есть два типа свойств объекта.
    1. Свойства-данные (`data properties`).
        - Все свойства, которые мы использовали до текущего момента были таковыми.
    2. Свойства-аксессоры (`accessor properties`).
    - По своей сути, это функции, которые используются для присвоения и получения значения, но во внешнем коде они выглядят как обычные свойства объекта.
- Геттеры и сеттеры:
    ```js
    let obj = {
        get propName() {
            // геттер, срабатывает при чтении obj.propName
        },
        set propName(value) {
            // сеттер, срабатывает при записи obj.propName = value
        }
    }
    ```
    - Пример:
        ```js
        let user = {
            name: 'John',
            surname: 'Smith',
            get fullName() {
                return `${this.name} ${this.surname}`
            },
            set fullName(value) {
                [this.name, this.surname] = value.split(' ')
            }
        }
        alert(user.fullName) // John Smith
        user.fullName = 'Alice Cooper'
        alert(user.name) // Alice
        alert(user.surname) // Cooper
        ```
- Дескрипторы свойств доступа:
    - Дескрипторы свойств-аксессоров отличаются от обычных свойств-данных.
    - Свойства-аксессоры не имеют `value` и `writable`, но взамен предлагают функции `get` и `set`.
    - То есть дескриптор аксессора может иметь:
        - `get`:
            - Функция без аргументов, которая срабатывает при чтении свойства.
        - `set`:
            - Функция, принимающая один аргумент, вызываемая при присвоении свойства.
        - `enumerable`:
            - То же самое, что и для свойств-данных.
        - `configurable`:
        - То же самое, что и для свойств-данных.
- Умные геттеры/сеттеры:
    - Геттеры/сеттеры можно использовать как обёртки над реальными значениями, чтобы получить больше контроля над операциями с ними.
    - Например, если мы хотим запретить устанавливать короткое имя для `user`, мы можем использовать сеттер `name` для проверки, а само значение хранить в отдельном свойстве `_name`:
        ```js
        let user = {
            get name() {
                return this._name
            },
            set name(value) {
                if (value.length < 4) {
                    alert('Имя слишком короткое, должно быть более 4 символов')
                    return
                }
                this._name = value
            }
        }
        user.name = 'Pete'
        alert(user.name) // Pete
        user.name = '' // Имя слишком короткое...
        ```
    - Технически, внешний код всё ещё может получит доступ к имени напрямую с помощью `user.name`, но существует широко известное соглашение о том, что свойства, которые начинаются с символа `_`, являются внутренними, и к ним не следует обращаться из-за пределов объекта.
- Использование для совместимости:
    - У аксессоров есть интересная область применения - они позволяют в любой момент взять обычное свойство и изменить его поведение, поменяв на геттер и сеттер.
    - Например, представим, что мы начали реализовывать объект `user`, используя свойства-данные имя `name` и возраст `age`:
        ```js
        function User(name, age) {
            this.name = name
            this.age = age
        }
        let john = new User('John', 25)
        alert(john.age) // 25
        ```
    - Но рано или поздно всё может измениться. Взамен возраста `age` мы можем решить хранить дату рождения `birthday`, потому что так более точно и удобно.
        ```js
        function User(name, birthday) {
            this.name = name
            this.birthday = birthday
        }
        let john = new User('John', new Date(1992, 6, 1))
        ```
    - Что нам делать со старым кодом, который использует свойство `age`?
    - Мы можем найти все такие места и изменить их, но это отнимает время и может быть невыполнимо, если код используется другими людьми.
    - И кроме того, `age` - отличное свойство для `user`, верно?
    - Давайте его сохраним.
        ```js
        function User(name, birthday) {
            this.name = name
            this.birthday = birthday
        }
        Object.defineProperty(this, 'age', {
            get() {
                let todayYear = new Date().getFullYear()
                return todayYear - this.birthday.getFullYear()
            }
        })
        let john = new User('John', new Date(1992, 6, 1))
        alert(john.birthday) // доступен как день рождения
        alert(john.age) // ...так и возраст
        ```
