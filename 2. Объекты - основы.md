# Объекты - основы

## 1. Объекты
- Упорядочение свойств объекта:
	- Свойства упорядочены особым образом:
        - Свойства с целочисленными ключами сортируются по возрастанию, остальные располагаются в порядке создания.
        ```js
        let codes = {
            '49': 'Германия',
            '41': 'Швейцария',
            '44': 'Великобритания',
            // ...,
            '1': 'США'
        }
        for (let code in codes) {
            alert(code) // 1, 41, 44, 49
        }
        ```
	- Целочисленные свойства:
	    - Означает строку, которая может быть преобразована в целое число и обратно без изменений:
            ```js
            '49' // +
            '+49' // -
            '1.2' // -
            ```

## 2. Копирование объектов и ссылки
- Одним из фундаментальных отличий объектов от примитивных типов данных является то, что они хранятся и копируются по ссылке.
- Примитивные типы - присваиваются и копируются по значению.
- Сравнение по ссылке:
	- Операторы равенства `==` и `===` для объектов работают одинаково.
	- Два объекта равны только в том случае, если это один и тот же объект.
- Клонирование и объединение объектов, `Object.assign`:
  ```js
  Object.assign(dest, [src1, src2, src3])
  ```
- Но это клонирование не глубокое, то есть он не дублирует вложенные объекты.

## 4. Конструкторы, создание объектов через new
- Функция-конструктор:
    - Являются обычными функциями, но есть два соглашения:
        1. Имя функции-конструктора должно начинаться с большой буквы.
        2. Функция-конструктор должна вызываться при помощи оператора `new`.
        ```js
        function User(name) {
            this.name = name
            this.isAdmin = false
        }
        let user = new User('Вася')
        alert(user.name) // Вася
        alert(user.isAdmin) // false
        ```
        - Другими словами:
        ```js
        function User(name) {
            // this = {}
            this.name = name
            this.isAdmin = false
            // return this
        }
        ```
        - То есть, результат вызова new User('Вася') - это тот же объект, что и:
        ```js
        let user = {
            name: 'Вася',
            isAdmin: false
        }
        ```
- Проверка на вызов в режиме конструктора: `new.target`
    - Используя специальное свойство `new.target` внутри функции, мы можем проверить, вызвана ли функция при помощи оператора `new` или без него.
    - В случае если функция вызвана при помощи `new`, то в `new.target` будет сама функция, в противном случае `undefined`.
- Возврат значения из конструктора `return`:
    - Обычно конструкторы ничего не возвращают явно.
    - Но если return всё же есть, то применяется простое правило:
        - При вызове `return` с объектом, будет возвращён объект, а не `this`.
        - При вызове `return` с примитивным значением, примитивное значение будет отброшено.
    - Другими словами, `return` с объектом возвращает объект, в любой другом случае конструктор вернёт `this`.
- Кстати, мы можем не ставить скобки после `new`, если вызов конструктора идёт без аргументов.

## 5. Методы объекта
- Метод объекта:
    ```js
    const user = {
        sayHi: function() {
            alert('Привет')
        }
    }
    const user = {
        sayHi() {
            alert('Привет')
        }
    }
    ```
- Ключевое слово `this` в методах:
    - Для доступа к информации внутри объекта метод может использовать ключевое слово `this`.
    - Значение `this` - это объект 'перед точкой', который использовался для вызова метода.
- `this` не является фиксированным:
    - Значение `this` вычисляется во время выполнения кода и зависит от контекста.
    - Правило простое: при вызове `obj.f()` значение `this` внутри `f` равно `obj`.
- Вызов без объекта:
    ```js
    function sayHi() {
        alert(this)
    }
    ```
    - В строгом режиме в таком коде значением `this` будет `undefined`.
    - В нестрогом режиме значением `this` в таком случае будет глобальный объект (`window` для браузера).
- Внутренняя реализация: Ссылочный тип:
    - Для работы вызова типа `user.hi()`, `JS` использует трюк - точка `.` возвращает не саму функцию, а специальное значение 'ссылочного типа', называемого `Reference Type`.
    - Является внутренним типом, мы не можем явно использовать его, но он используется внутри языка.
    - Значение ссылочного типа - это триплет `(base, name, strict)`.
        - `base` - это объект.
        - `name` - это имя свойства объекта.
        - `strict` - это режим исполнения, true если действует строгий режим.
    - Результатом доступа к свойству `user.hi` является не функция, а значение ссылочного типа.
    - Для `user.hi` в строгом режиме оно будет таким: `(user, 'hi', true)`
    - Когда скобки `()` применяются к значению ссылочного типа (происходит вызов), то они получаются полную информацию об объекте и его методе, и могут поставить правильный `this`.
    - Ссылочный тип - исключительно внутренний, промежуточный, используемый чтобы передать информацию от точки `.` до вызывающих скобок `()`.
    - При любой другой операции, например, присваивании `hi = user.hi`, ссылочный тип заменяется на собственно значение `user.hi` (функцию), и дальше работа уже идёт только с ней.
    - Поэтому дальнейший вызов происходит уже без `this`.
- У стрелочных функций нет `this`:
    Если мы используем `this` внутри стрелочной функции, то его значение берётся из внешней 'нормальной' функции.
 
## 7. Тип данных `Symbol`
- По спецификации, в качестве ключей для свойств объекта могут использоваться только строки или символы.
- Ни числа, ни логические значения не подходят, разрешены только эти два типа данных.
- Символы:
    - Представляет собой уникальный идентификатор.
    - Создаются с помощью функции `Symbol()`.
    - При создании можно дать описание внутри скобок:
        ```js
        let id = Symbol('id')
        ```
    - Символы гарантированно уникальны.
    - Даже если мы создадим множество символов с одинаковым описанием, это всё равно будут разные символы.
    - Описание это просто метка, которая ни на что не влияет.
    - Символы не преобразуются автоматически в строки.
    - Это языковая защита от путаницы, ведь строки и символы - принципиально разные типы данных и не должны неконтролируемо преобразовываться друг в друга.
    - Если мы действительно хотим вывести символ с помощью `alert`, то необходимо явно преобразовывать его с помощью метода `.toString()`.
- Скрытые свойства:
    - Символы позволяют создавать скрытые свойства объектов, к которым нельзя нечаянно обратиться и перезаписать их из других частей программы.
    - Если объект пришёл к нам из стороннего кода, то лучше не присваивать ему свойства для защиты.
        ```js
        let user = {
            name: 'Вася'
        }
        let id = Symbol('id')
        user[id] = 1
        alert(user[id])
        ```
- Символы в литеральном объекте:
    - Если мы хотим использовать символ при литеральном объявлении объекта `{...}`, его необходимо заключить в квадратные скобки.
        ```js
        let id = Symbol('id')
        let user = {
            name: 'Вася',
            [id]: 123
        }
        ```
- Символы игнорируются циклом `for...in`:
    - Свойства, чьи ключи - символы, не перебираются циклом `for...in`.
- А вот `Object.assign`, в отличии от цикла `for...in`, копирует и строковые, и символьные свойства.
- Глобальные символы:
    - Для чтения (или, при отсутствии, создания) символа из реестра используется вызов `Symbol.for(key)`.
        ```js
        let id = Symbol.for('id')
        let idAgain = Symbol.for('id')
        alert(id === idAgain) // true
        ```
- `Symbol.keyFor`:
    - Для глобальных символов существует обратный метод: Symbol.keyFor(sym), который, наоборот, принимает глобальный символ и возвращает его имя.
        ```js
        let sym = Symbol.for('name')
        let sym2 = Symbol.for('id')
        alert(Symbol.keyFor(sym)) // name
        alert(Symbol.keyFor(sym2)) // id
        ```
- Системные символы:
    - `Symbol.hasInstance`
    - `Symbol.isConcatSpreadable`
    - `Symbol.iterator`
    - `Symbol.toPrimitive`
    - и тд.
    - В частности, `Symbol.toPrimitive` позволяет описать правила для объекта, согласно которым он будет преобразовываться к примитиву.

## 8. Преобразование объектов в примитивы
1. Все объекты в логическом контексте являются `true`. Существуют лишь их численные и строковые преобразования.
2. Численные преобразования происходят, когда мы вычитаем объекты или выполняем математические операции.
3. Что касается строковых преобразований - они обычно происходят, когда мы выводим объект `alert(obj)`, а также в других случаях, когда объект используется как строка.
- Преобразование к примитивам:
    - Мы можем тонко настраивать строковые и численные преобразования, используя специальные методы объекта.
    - Существуют три варианта преобразований (три хинта), описанные в спецификации.
- `string`:
    - Для преобразования объекта к строке, когда операция ожидает получить строку, например `alert`.
- `number`:
    - Для преобразования объекта к числу, в случае математических операций.
        ```js
        let num = Number(obj)
        let n = +obj
        let delta = date1 - date2
        let greater = user1 > user2
        ```
- `default`:
    - Происходит редко, когда оператор не уверен, какой тип ожидать.
    - Например, бинарный плюс + может работать с обоими типами: строками (объединять их) и числами (складывать).
    - Таким образом, и те, и другие будут вычисляться. Или когда происходит сравнение объектов с помощью нестрогого равенства `==` со строкой, числом или символом, и неясно, какое преобразование должно быть выполнено.
    - Оператор больше/меньше `<>` также может работать как со строками, так и с числами. Однако, по историческим причинам он использует хинт `number`, а не `default`.
    - На практике все встроенные объекта, исключая `Date`, реализуют `default` преобразования тем же способом, что и `number`.
    - И нам следует поступать так же.
- В процессе преобразовывания движок `JS` пытается найти и вызвать три следующих метода объекта:
    1. Вызывает `obj[Symbol.toPrimitive](hint)` - метод с символьным ключом, если такой метода существует, и передаёт ему хинт.
    2. Иначе, если хинт равен `string`:
        - Пытается вызвать `obj.toString()`, а если его нет, то `obj.valueOf()`, если он существует.
    3. В случае, если хинт равен `number` или `default`:
        - Пытается вызвать `obj.valueOf()`, а если его нет, то `obj.toString()`, если он существует.
- `Symbol.toPrimitive`:
    ```js
        obj[Symbol.toPrimitive] = function(hint) {
            // должен вернуть примитивное значение
            // hint равно чему-то одному из 'string', 'number' или 'default'
        }
        let user = {
            name: 'John',
            money: 1000,
            [Symbol.toPrimitive](hint) {
                alert(`hint: ${hint}`)
                return hint == 'string' ? `{name: "${this.name}"}` : this.money
            }
        }
        alert(user) // hint: string -> {name: 'John'}
        alert(+user) // hint: number -> 1000
        alert(user + 500) // hint: default -> 1500
    ```
- Методы `toString/valueOf`:
    - Предоставляют устарвший способ реализации преобразований объектов.
        - `toString` -> `valueOf` для хинта со значением `string`.
        - `valueOf` -> `toString` - в ином случае.
- Возвращаемые типы:
    - Описанные методы для преобразований объектов не обязаны возвращать именно требуемый хинтом тип примитива.
    - Единственное обязательно требование: методы должны возвращать примитив, а не объект.
