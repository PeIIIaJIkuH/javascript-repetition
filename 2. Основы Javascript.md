# Основы `Javascript`

## 2. Структура кода
- Точку с запятой можно не ставить, но в некоторых случаях это необходимо. К примеру:
    ```js
    alert("Сейчас будет ошибка")
    [1, 2].forEach(alert)
    ```
- Сам `JS` думает, что `[]` идёт сразу после скобок, и получается конструкция вида:
    ```js
    alert("Сейчас будет ошибка")[1, 2].forEach(alert)
    ```
- Это вызывает ошибку.

## 3. Строгий режим &ndash; `use strict`
- Писать нужно в самом начале кода: `'use strict'` или `"use strict"`.
- Над этой командой можно писать только коментарии.
- Нельзя отменить.
- Можно написать в начале функции, чтобы эта команда распространялась только на данную функцию.
- В модульном коде включён по умолчанию.

## 4. Переменные
- Имя переменной может содержать буквы, цифры или символы `$` или `_`.
- Нельзя начинать имя с цифры.
- Без `'use strict'` можно создать переменную без объявления `(var, let, const)`.
- Такая переменная становится глобальной, то есть к ней можно получить доступ через `window` или `global`.

## 5. Типы данных
- 8 типов данных:
    - `number`:
        - Специальные числовые значения: `Infinity`, `-Infinity`, `NaN`.
        - Любая операция с NaN возвращает `NaN`.
        - Математические операции безопасны - исключается возможность появления ошибки.
    - `bigInt`:
        - `number` -> `min`: -(2^53-1), `max`: 2^53-1.
        - `BigInt` -> нет максимальных и минимальных значений.
    - `string`
    - `boolean`
    - `null`
    - `undefined`
    - `object`
- `typeof`:
    ```js
    typeof x
    typeof (x)
    typeof null == 'object' // ошибка языка, на самом деле null не объект
    ```

## 7. Преобразование типов
- Строковое:
    - Происходит очевидным образом:
        - `false` -> '`false'`
        - `null` -> `'null'`.
- Численное:
    ```js
    Number(undefined) == NaN
    Number(null) == 0
    Number(true) == 1
    Number(false) == 0
    Number(string) // => делается trim() => если пустая строка, то 0, при ошибке - NaN
    ```
- Логическое:
    - Значения, которые интуитивно пустые, вроде `0`, `''`, `null`, `undefined` и `NaN`, становится `false`. Остальные - `true`.

## 8. Базовые операторы, математика
- Операнд - то, к чему применяется оператор.
- Унарный оператор - применяется к одному операнду.
- Бинарный оператор - к двум.
- `**` - возведение в степень.
- Инкремент / декремент можно применить только к переменным.
- Оператор `,`:
    - Позволяет вычислять несколько выражений, и возвращает последнее.
    - Имеет самый низкий приоритет, из-за этого нужно обернуть значения скобками.

## 9. Оператор сравнения
- Сравнения строк:
    1. Сравниваются первые символы.
    2. Если первый символ меньше/больше второго, то и сама строка меньше/больше второго, сравнение завершено.
    3. Если первые равны, сравнение идёт до конца.
    4. Продолжается пока не закончится одна из строк.
    5. Если обе строки заканчиваются одновременно, то они равны. Иначе, большей считается более длинная строка.
- Сравнение разных типов:
    - Каждый из них приводится к числу.
- Сравнение с `null` и `undefined`:
    ```js
    null === undefined // false
    null == undefined // true
    ```
    - При использовании математических операторов и других операторов сравнения `<`, `>`, `<=`, `>=`, значения `null/undefined` преобразуются к числам:
        - `null` -> `0`
        - `undefined` -> `NaN`

- Странный результат сравнения `null` и `0`:
    ```js
    null > 0 // false
    null == 0 // false
    null >= 0 // true
    ```
    - Причина в том, что операторы сравнения и равенства работают по-разному:
        - Сравнения преобразуют `null` в число.
        - Для нестрогого равенства `==` значений `undefined` и `null` действует особое правило:
            - Эти значения ни к чему не приводятся, они равны друг другу и не равны ничему другому.
- Несравненное значение `undefined`:
    - `undefined` несравнимо с другими значениями.
        ```js
        undefined > 0 // (1) false
        undefined < 0 // (2) false
        undefined == 0 // (3) false
        ```
    - 1, 2 -> `undefined` преобразуется в `NaN`, а `NaN` возвращает `false` при любых сравнениях.
    - 3 -> Тут всё понятно.

## Условные ветвления
- Инструкция `if(...)` вычисляет выражение в скобках и преобразует результат к логическому типу.
- Вспомним правила:
    - `0`, `''`, `null`, `undefined`, `NaN` -> `false`.
    - Остальное -> `true`.

## 11. Логические операторы
- Преобразуют значения к булевому типу.
- `||`:
    - Находит первое истинное значение.
    - Вычисляет операнды слева направо.
    - Каждый операнд конвертируется в логическое значение, если результат true, останавливается и возвращает исходное
      значение этого операнда.
    - Если все операнды являются ложными, возвращает последнее из них.
- `&&`:
    - Находит первое ложное значение.
    - Вычисляет операнды слева направо.
    - Каждый операнд конвертируется в логическое значение, если результат false, останавливается и возвращает исходное
      значение этого операнда.
    - Если все операнды являются истинными, возвращает последнее из них.
- Приоритет у `&&` выше, чем у `||`.

## 12. Оператор объединения с `null`
- Возвращает первый аргумент, если он не `null/undefined`, иначе второй.
- Довольно низкий приоритет, лучше использовать скобки.

## 13. Циклы `while` и `for`
- Метки для `break/continue`:
    - Когда нужно выйти одновременно из нескольких уровней цикла сразу:
        ```js
        outer:
        for (let i = 0; i < 3; i++) {
            for (let j = 0; j < 3; j++) {
                if ('something is wrong') {
                    break outer;        
                }
            }
        }
        ```
- Метки не позволяют прыгать куда угодно, вызов меток возможен только внутри цикла, и метка должны находиться выше этой
  директивы.

## 14. Конструкция `switch`
- Группировка `case`:
    ```js
    switch (x) {
        case 4:
            // something
            break
        case 5:
        case 6:
            // something
            break
    }
    ```
- Тип имеет значение:
    - Проверка на равенство в case всегда строгая `===`.

## 15. `Function Expression`
- Function Declaration:
    ```js
    function a() {}
    ```
- `Function Expression`:
    ```js
    const a = function() {}
    ```
- Отличия:
    - `Function Expression` создаётся, когда выполнение доходит до него, и затем уже может использоваться.
    - `Function Declaration` можно использовать во всём скрипте (или блоке кода, если функция объявлена в блоке).
    - В строгом режиме, когда `Function Declaration` находится в блоке `{...}`, функция доступна везде внутри блока, но не
      снаружи него.
