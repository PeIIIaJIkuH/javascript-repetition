# Прототипы, наследование

## 1. Прототипное наследование
- Мы часто хотим взять что-то и расширить.
- Например, есть объект user со своими свойствами и методами, и мы хотим создать объекты `admin` и `guest` как его слегка изменённые варианты. Мы хотели бы повторно использовать то, что есть у объекта `user`, не копировать/переопределять его методы, а просто создать новый объект на его основе.
- `Прототипное наследование` - это возможность языка, которая помогает в этом.
- `[[Prototype]]`:
    - В `JS` объекты имеют специальное скрытое свойство `[[Prototype]]` (так оно названо в спецификации), которое либо равно `null`, либо ссылатся на другой объект. 
    - Этот объект называется прототип.
    - Он даёт нам немного магии, когда мы хотим прочитать свойство из `object`, а оно отсутствует, `JS` автоматически берёт его из прототипа.
    - В программировании такой механизм называется прототипным наследованием.
    - Свойство `[[Prototype]]` является внутренним и скрытым, но есть много способов задать его.
    - Одним из является использование `__proto__`:
        ```js
        let animal = {
            eats: true
        }
        let rabbit = {
            jumps: true
        }
        rabbit.__proto__ = animal
        ```
    - Свойство `__proto__` - исторически обусловленный геттер/сеттер для `[[Prototype]]`.
        - Обратите внимание, что `__proto__` не то же самое, что `[[Prototype]]`.
        - Он существует по историческим причинам, в современном языке его заменяют функции `Object.getPrototypeOf/Object.setPrototypeOf`, которые также получают/устанавливают прототип.
        - По спецификации `__proto__` должен поддерживаться только браузерами, но по факту все среды, включая серверную, поддерживают его.
    - Если мы ищем свойство в `rabbit`, а оно отсутствует, `JS` автоматически берёт его из `animal`.
        ```js
        alert(rabbit.eats) // true
        alert(rabbit.jumps) // true
        ```
    - Когда `alert` пытается прочитать свойство `rabbit.eats`, его нет в `rabbit`, поэтому `JS` следует по ссылке `[[Prototype]]` и находит его в `animal`.
    - Здесь мы можем сказать, что animal является прототипом `rabbit` или `rabbit` прототипно наследует от `animal`.
    - Цепочка прототипов может быть длиннее.
    - Есть только два ограничения?:
        1. Ссылки не могут идти по кругу. `JS` выдаст ошибку, если мы попытаемся назначить `__proto__` по кругу.
        2. Значение `__proto__` может быть объектом или `null`. Другие типы игнорируются.
            Может быть только один `[[Prototype]]`. Объект не может наследоваться от двух других объектов.
- Операция записи не использует прототип:
    - Прототип используется только для чтения свойств.
    - Операция записи/удаления работают напрямую с объектом.
        ```js
        let animal = {
            eats: true,
            walk() {
                // этот метод не будет использоваться в rabbit
            }
        }
        let rabbit = {
            __proto__: animal
        }
        rabbit.walk = function() {
            alert('Rabbit! Bounce-bounce!')
        }
        rabbit.walk() // Rabbit! Bounce-bounce!
        ```
    - Свойства-аксессоры - исключение, так как запись в него обрабатывается функцией-сеттером.
    - То есть, это, фактически, вызов функции.
    - По этой причине `admin.fullName` работает корректно в приведённом ниже коде:
        ```js
        let user = {
            name: 'John',
            surname: 'Smith',
            set fullName(value) {
                [this.name, this.surname] = value.split(' ')
            },
            get fullName() {
                return `${this.name} ${this.surname}`
            }
        }
        let admin = {
            __proto__: user,
            isAdmin: true
        }
        alert(admin.fullName) // John Smith
        admin.fullName = 'Alice Cooper'
        alert(admin.name) // Alice
        alert(admin.surname) // Cooper
        ```
- Значение `this`:
    - В приведённом выше примере может возникнуть интересный вопрос: каково значение `this` внутри `set fullName(value)`?
    - Куда записаны свойства `this.name` и `this.surname`: в `user` или в `admin`?
    - Ответ прост: прототипы никак не влияют на `this`.
    - Неважно, где находится метод: в объекте или его прототипе. При вызове метода `this` - всегда объект перед точкой.
    - Таким образом, вызов сеттера `admin.fullName=` в качестве `this` использует `admin`, а не `user`.
- Цикл `for..in`:
    - Цикл `for..in` проходит не только по своим собственным, но и по унаследованным свойствам объекта.
    - Если унаследованные свойства нам не нужны, то мы можем отфильтровать их при помощи встроенного метода `obj.hasOwnProperty(key)`:
        - Он возвращает `true`, если у `obj` есть собственное, не унаследованное, свойство с именем `key`.
    - Заметим ещё одну деталь. Откуда взялся метод `rabbit.hasOwnProperty`?
    - Мы его явно не определяли.
    - Если посмотреть на цепочку прототипов, то видно, что он берётся из `Object.prototype.hasOwnProperty`.
    - То есть, он унаследован.
    - Но почему `hasOwnProperty` не появляется в цикле `for..in` в отличие от `eats` и `jumps`?
    - Он ведь перечисляет все унаследованные свойства.
    - Ответ простой: оно не перечислимо. То есть у него внутренний флаг `enumerable` стоит `false`, как и у других свойств `Object.prototype`.
    - Поэтому оно и не появляется в цикле.
    - Почти все остальные методы получения ключей/значений игнорируют унаследованные свойства:
        - Почти все остальные методы, получающие ключ/значение, такие как `Object.keys`, `Object.values` и другие - игнорируют унаследованные свойства.
        - Они учитывают только свойства самого объекта, не его прототипа.

## 2. F.prototype
- Как мы помним, новые объекты могут быть созданы с помощью функции-конструктора `new F()`.
- Если в `F.prototype` содержится объект, оператор `new` устанавливает его в качестве `[[Prototype]]` для нового объекта.
- `JS` использовал прототипное наследование с момента своего появления.
- Это одна из основных особенностей языка.
- Но раньше, в старые времена, прямого доступа к прототипу объекта не было.
- Надёжно работало только свойство `prototype` функции-конструктора, описанное в этой главе.
- Поэтому оно используется во многих скриптах.
- Обратите внимание, что `F.prototype` означает обычное свойство с именем `prototype` для `F`.
- Это ещё не прототип объекта, а обычное свойство `F` с таким именем.
    ```js
    let animal = {
        eats: true
    }
    function Rabbit(name) {
        this.name = name
    }
    Rabbit.prototype = animal
    let rabbit = new Rabbit('White Rabbit') // rabbit.__proto__ == animal
    alert(rabbit.eats) // true
    ```
- Установка `Rabbit.prototype = animal` буквально говорит интерпретатору следующее:
    - При создании объекта через `new Rabbit()` запиши ему `animal` в `[[Prototype]]`.
- `F.prototype` используется только в момент вызова `new F()`:
    - `F.prototype` используется только при вызове `new F()` и присваивается в качестве свойства `[[Prototype]]` нового объекта.
    - После этого `F.prototype` и новй объект ничего не связывает.
    - Следует понимать это как единоразовый подарок объекту.
    - После создания `F.prototype` может измениться, и новые объекты, созданные с помощью `new F()`, будут иметь другой объект в качестве `[[Prototype]]`, но уже существующие объекты сохранят старый.
- `F.prototype` по умолчанию, свойство `constructor`:
    - У каждой функции по умолчанию уже есть свойство `prototype`.
    - По умолчанию `prototype` - объект с единственным свойством `constructor`, которое ссылается на функцию-конструктор.
        ```js
        function() {}
        // прототип по умолчанию
        // Rabbit.prototype = {constructor: Rabbit}
        alert(Rabbit.prototype.constructor == Rabbit) // true
        ```
    - Соответственно, если мы ничего не меняем, то свойство `constructor` будет доступно всем кроликам через `[[Prototype]]`.
        ```js
        let rabbit = new Rabbit()
        alert(rabbit.constructor == Rabbit) // true
        ```
    - Мы можем использовать свойство constructor существующего объекта для создания нового.
        ```js
        function Rabbit(name) {
            this.name = name
            alert(name)
        }
        let rabbit = new Rabbit('White Rabbit')
        let rabbit2 = new rabbit.constructor('Black Rabbit')
        ```
    - Это удобно, когда у нас есть объект, но мы не знаем, какой конструктор использовался для его создания, а нам необходимо создать ещё один такой объект.
    - Но, пожалуй, самое важное о свойстве `constructor` это то, что `JS` сам по себе не гарантирует правильное значение свойства `constructor`.
    - Да, оно является свойством по умолчанию в `prototype` у функции, но что случится с ним позже зависит только от нас.
    - В частности, если мы заменим прототип по умолчанию на другой объект, то свойства
        ```js
        'constructor' в нём не будет.
        function Rabbit() {}
        Rabbit.prototype = {
            jumps: true
        }
        let rabbit = new Rabbit()
        alert(rabbit.constructor === Rabbit) // false
        ```
    - Таким образом, чтобы сохранить верное свойство `constructor`, мы должны добавлять/удалять/изменять свойства у прототипа по умолчанию вместо того, чтобы перезаписывать его целиком.
        ```js
        function Rabbit() {}
        Rabbit.prototype.jumps = true
        ```
    - Или мы можем заново создать свойство `constructor`.
        ```js
        Rabbit.prototype = {
            jumps: true,
            constructor: Rabbit
        }
        ```

## 3. Встроенные прототипы
- `Object.prototype`:
    - Давайте выведем пустой объект.
        ```s
        let obj = {}
        alert(obj) // '[object Object]'
        ```
    - Где код, который генерирует строку `[object Object]`? Это встроенный метод `toString`, но где он?
    - Но краткая нотация `obj = {}` - это то же самое, что и `obj = new Object()`, где `Object` - встроеная функция-конструктор для объектов с собственным свойством `prototype`, которое ссылается на огромный объект с методом `toString` и другими.
    - Когда создаётся новый объект, свойство `[[Prototype]]` этого объекта устанавливается на `Object.prototype` по правилам, которые мы обсуждали в предыдущей главе.
    - Таким образом, когда вызывается `obj.toString()`, метод берётся из `Object.prototype`.
- Другие встроенные прототипы:
    - Другие встроенные объекты, такие как `Array`, `Date`, `Function` и другие, также хранят свои методы в прототипах.
    - Согласно спецификации, наверху иерархии встроенных прототипов находится `Object.prototype`.
    - Поэтому иногда говорят, что всё наследует от объектов.
    - Некоторые методы в прототипах могут пересекаться, например, у `Array.prototype` есть свой метод `toString`, который выводит элементы массива через запятую.
    - Как мы видели, у `Object.prototype` есть свой метод `toString`, но так как `Array.prototype` ближе в цепочке прототипов, то берётся именно вариант для массивов.
- Примитивы:
    - Самое сложное происходит со строками, числами и булевыми значениями.
    - Как мы помним, они не объекты.
    - Но если мы попытаемся получить доступ к их свойствам, то тогда будет создан временный объект-обёртка с использованием встроенных конструкторов `String`, `Number` и `Boolean`, который предоставит методы и после этого исчезнет.
    - Эти объекты создаются невидимо для нас, и большая часть движков оптимизирует этот процесс, но спецификация описывает это именно таким образом.
    - Методы этих объектов также находятся в прототипах, доступных как `String.prototype`, `Number.prototype` и `Boolean.prototype`.
    - Значения `null` и `undefined` не имеют объектов-обёрток.
    - Также у них нет соответствующих прототипов.
- Изменение встроенных прототипов:
    - Например, если добавить метод к `String.prototype`, метод становится доступен для всех строк.
        ```js
        String.prototype.show = function() {
            alert(this)
        }
        'BOOM!'.show() // BOOM!
        ```
    - В течение процесса разработки у нас могут возникнуть идеи о новых встроенных методах, которые нам хотелось бы иметь, и искушение добавить их во все встроенные прототипы.
    - Это плохая идея.
    - Прототипы глобальные, поэтому очень легко могут возникнуть конфликты.
    - Если две библиотеки добавляют метод `String.prototype.show`, то одна из них перепишет метод другой.
    - В современном программировании есть только один случай, в котором одобряется изменение встроеных прототипов. Это создание полифилов.
    - `Полифил` - это термин, который означает эмуляцию метода, который существует в спецификации `JS`, но ещё не поддерживается текущим движком `JS`.
    - Тогда мы можем реализовать его сами и добавить во встроенный прототип.
- Заимствование к прототипов:
    - Это когда мы берём метод из одного объекта и копируем его в другой.
    - Некоторые методы встроенных прототипов часто одалживают.
    - Например, если мы создаём объект, похожий на массив (псевдомассив), мы можем скопировать некоторые методы из `Array` в этот объект.
        ```js
        let obj = {
            0: 'Hello',
            1: 'wordl!',
            length: 2
        }
        obj.join = Array.prototype.join
        alert(obj.join(',')) // Hello,world!
        ```
    - Это работает, потому что для внутреннего алгоритма встроенного метода `join` важны только корректность `индексов` и свойство `length`, он не проверяет, является ли объект на самом деле массивом.
    - И многие встроенные объекты работают так же.
    - Альтернативная возможность - мы можем унаследовать от массива, установив `obj.__proto__` как `Array.prototype`, таким образом все методы `Array` станут автоматически доступны в `obj`.
    - Но это будет невозможно, если `obj` уже наследует от другого объекта.
    - `Заимствование методов` - гибкий способ, позволяющий смешивать функциональность разных объектов по необходимости.

## 4. Методы прототипов, объекты без свойства `__proto__`
- Существуют современные методы работы с прототипами.
- Свойство `__proto__` считается устаревшим, и по стандарту оно должно поддерживаться только браузерами.
- Современные методы:
    - `Object.create(proto, [descriptors])`:
        - Создаёт пустой объект со свойством `[[Prototype]]`, указанным как `proto`, и необязательными дескрипторами свойств `descriptors`.
    - `Object.getPrototypeOf(obj)`:
        - Возвращает свойство `[[Prototype]]` объекта `obj`.
    - `Object.setPrototypeOf(obj, proto)`:
        - Устанавливает свойство `[[Prototype]]` объект `obj` как `proto`.
- Эти методы нужно использовать вместо `__proto__`:
    ```js
    let animal = {
        eats: true
    }
    let rabbit = Object.create(animal)
    alert(rabbit.eats) // true
    alert(Object.getPrototypeOf(rabbit) === animal) // получаем прототип объекта rabbit
    Object.setPrototypeOf(rabbit, {}) // заменяем прототип объекта на {}
    ```
- У `Object.create` есть необязательный второй аргумент: дескрипторы свойств.
    ```js
    let animal = {
        eats: true
    }
    let rabbit = Object.create(animal, {
        jumps: {
            value: true
        }
    })
    alert(rabbit.jumps) // true
    ```
- Мы также можем использовать `Object.create` для продвинутого клонирование объекта, более мощного, чем копирование свойств в цикле `for..in`.
    ```js
    let clone = Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj))
    ```
- Такой вызов создаёт точную копию объекта `obj`, включая все свойства: перечисляемые и неперечисляемые, геттеры/сеттеры для свойств - и всё это с правильным свойством `[[Prototype]]`.
- Краткая история:
    - Очень много способов управления прототипом, и многие делают одно и то же.
    - Почему так?
    - В силу исторических причин:
        - Свойство prototype функции-конструктора существует совсем с давних времён.
        - В `2012` году, в стандарте появился метод `Object.create`. Это давало возможность создавать объекты с указанным прототипом, но не позволяло устанавливать/получать его. Тогда браузеры реализовали нестандартный аксессор `__proto__`, который позволял устанавливать/получать прототип в любое время.
        - В `2015` году, в стандарт были добавлены `Object.setPrototypeOf` и `Object.getPrototypeOf`, заменяющие собой аксессор `__proto__`, который упоминается в Приложении Б Стандарта, которое не обязательно к поддержке в небраузерных окружениях. При этом де-факто `__proto__` всё ещё поддерживается везде.
    - В итоге сейчас у нас есть все эти способы для работы с прототипом.
    - Почему же `__proto__` был заменён на вышесказанные функции?
    - Не меняйте `[[Prototype]]` существующих объектов, если важна скорость:
        - Технически мы можем установить/получить `[[Prototype]]` в любое время.
        - Но обычно мы устанавливаем прототип только раз во время создания объекта, а после не меняем: `rabbit` наследует от `animal`, и это не изменится.
        - И `JS` движки хорошо оптимизированы для этого. Изменение прототипа на лету с помощью `Object.setPrototypeOf` или `obj.__proto__` очень медленная операция, которая ломает внутренние оптимизации доступа к свойствам объекта.
        - Так что лучше избегайте этого кроме тех случаев, когда вы знаете, что делаете, или же когда скорость `JS` для вас не имеет никакого значения.
- Простейший объект:
    - Объекты можно использовать как ассоциативные массивы для хранения пар ключ/значение.
    - Но если мы попробуем хранить созданные пользователеми ключи (например, словари с пользовательским вводом), мы можем заметить интересный сбой: все ключи работают как ожидается, за исключением `__proto__`.
        ```js
        let obj = {}
        let key = prompt('What's the key?', '__proto__')
        obj[key] = 'some value'
        alert(obj[key]) // [object Object], не 'some value'!
        ```
    - Если пользователь введёт `__proto__`, присвоение проигнорируется!
    - Это происходит из-за того, что свойство `__proto__` является сеттером, и функция проверяет правую сторону выражения.
    - Чтобы избежать этого, можно либо использовать `Map`, либо следующее:
        ```js
        let obj = Object.create(null)
        let key = prompt('What's the key?', '__proto__')
        obj[key] = 'some value'
        alert(obj[key]) // 'some value'
        ```
    - `Object.create(null)` создаёт пустой объект без прототипа (`[[Prototype]]` будет `null`).
    - Таким образом не будет унаследованного геттера/сеттера для `__proto__`.
    - Мы можем назвать такой объект простейшим или чистым словарным объектом, потому что он ещё проще, чем обычные объекты `{...}`.
    - Недостаток в том, что у таких объектов не будет встроенных методов объекта, таких как `toString`.
    - Но обычно это нормально для ассоциативных массивов.
    - Обратите внимание, что большая часть методов с объектами, имеют вид `Object.something(...)`.
    - Подобные методы не находятся в прототипе, так что они продолжат работать для для таких объектов.
